<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PoCW Blockchain Inspector</title>
    <style>
        body { font-family: monospace; margin: 20px; background: #1a1a1a; color: #00ff00; }
        .container { max-width: 1200px; margin: 0 auto; }
        .section { margin: 20px 0; padding: 15px; border: 1px solid #333; background: #222; }
        .btn { padding: 8px 16px; background: #333; color: #00ff00; border: 1px solid #555; cursor: pointer; margin: 5px; }
        .btn:hover { background: #444; }
        input, select { padding: 8px; background: #333; color: #00ff00; border: 1px solid #555; margin: 5px; }
        .output { background: #111; padding: 15px; border: 1px solid #333; margin: 10px 0; max-height: 400px; overflow-y: auto; }
        .highlight { color: #ffff00; }
        .error { color: #ff0000; }
        .success { color: #00ff00; }
        h1, h2 { color: #00ffff; }
        .tx-hash { color: #ff6b6b; word-break: break-all; }
        .address { color: #4ecdc4; word-break: break-all; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç PoCW Blockchain Inspector</h1>
        
        <div class="section">
            <h2>Network Status</h2>
            <button class="btn" onclick="checkNetwork()">Check Network</button>
            <button class="btn" onclick="getLatestBlock()">Get Latest Block</button>
            <div id="network-status" class="output">Click "Check Network" to see status...</div>
        </div>

        <div class="section">
            <h2>Block Inspector</h2>
            <input type="number" id="blockNumber" placeholder="Block number (or leave empty for latest)" style="width: 200px;">
            <button class="btn" onclick="getBlock()">Get Block Details</button>
            <div id="block-output" class="output">Enter block number and click "Get Block Details"...</div>
        </div>

        <div class="section">
            <h2>Transaction Inspector</h2>
            <input type="text" id="txHash" placeholder="Transaction hash" style="width: 500px;">
            <button class="btn" onclick="getTransaction()">Get Transaction</button>
            <div id="tx-output" class="output">Enter transaction hash and click "Get Transaction"...</div>
        </div>

        <div class="section">
            <h2>Contract Inspector</h2>
            <select id="contractSelect">
                <option value="0x5FbDB2315678afecb367f032d93F642f64180aa3">HETU Token</option>
                <option value="0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512">Intelligence Token (KEY)</option>
                <option value="0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0">PoCW Mainnet</option>
            </select>
            <button class="btn" onclick="getContractInfo()">Get Contract Info</button>
            <div id="contract-output" class="output">Select contract and click "Get Contract Info"...</div>
        </div>

        <div class="section">
            <h2>Account Inspector</h2>
            <input type="text" id="accountAddress" placeholder="Enter address (miner, validator, etc.)" style="width: 400px;">
            <button class="btn" onclick="getAccountInfo()">Get Account Info</button>
            <div id="account-output" class="output">Enter address and click "Get Account Info"...</div>
        </div>

        <div class="section">
            <h2>Transaction Decoder</h2>
            <input type="text" id="decodeTxHash" placeholder="Transaction hash to decode" style="width: 500px;">
            <button class="btn" onclick="decodeTransaction()">Decode Transaction</button>
            <div id="decode-output" class="output">Enter transaction hash to decode contract calls...</div>
        </div>

        <div class="section">
            <h2>Recent Transactions</h2>
            <button class="btn" onclick="getRecentTransactions()">Get Last 10 Transactions</button>
            <div id="recent-tx-output" class="output">Click "Get Last 10 Transactions"...</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ethers@6.15.0/dist/ethers.umd.min.js"></script>
    <script>
        console.log("üîç PoCW Inspector loading...");
        
        let provider;
        let contractAddresses = {
            "HETUToken": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
            "KEYToken": "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512", 
            "SubnetRegistry": "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0",
            "EnhancedPoCWVerifier": "0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9"
        };

        const contractABIsByType = {
            "HETUToken": [
                "function balanceOf(address) view returns (uint256)",
                "function totalSupply() view returns (uint256)",
                "function name() view returns (string)",
                "function symbol() view returns (string)"
            ],
            "KEYToken": [
                "function balanceOf(address) view returns (uint256)",
                "function totalSupply() view returns (uint256)",
                "function name() view returns (string)",
                "function symbol() view returns (string)"
            ],
            "EnhancedPoCWVerifier": [
                "function getReputationScores(address) view returns (uint256, uint256)",
                "function calculateReputationScore(address) view returns (uint256)",
                "function calculateValidatorReputationScore(address) view returns (uint256)",
                "function minerIds(address) view returns (address, uint256, uint256, uint256, uint256, uint256, uint256, uint256, bool, bytes32)",
                "function getValidatorStats(address) view returns (tuple(uint256,uint256,uint256,uint256,bool,uint256,uint256,uint256))",
                "function getValidatorConfidenceScore(address) view returns (uint256)",
                "function getEpochSubmission(bytes32, uint256) view returns (tuple(uint256,bytes,address[],uint256,bool,bool,uint256))",
                "function getSubnet(bytes32) view returns (tuple(address[],uint256,bool,uint256,uint256))",
                "function verifyAndDistributeRewards(bytes32, uint256, bool) returns (bool)",
                "function submitAndDistributeEpoch(string memory subnetId, bytes memory vlcGraphData, address[] memory successfulMiners, uint256 successfulTasks, uint256 failedTasks) external"
            ]
        };

        let contractABIs = {};

        function updateContractABIs() {
            contractABIs = {};
            for (const [type, address] of Object.entries(contractAddresses)) {
                if (contractABIsByType[type]) {
                    contractABIs[address] = contractABIsByType[type];
                }
            }
        }

        async function loadContractAddresses() {
            try {
                console.log("üîÑ Loading contract addresses...");
                const response = await fetch('./contract_addresses.json');
                if (response.ok) {
                    const addresses = await response.json();
                    console.log("üìÑ Loaded addresses:", addresses);
                    
                    for (const [address, name] of Object.entries(addresses)) {
                        if (name === "HETU Token") contractAddresses.HETUToken = address;
                        else if (name === "Intelligence Token (KEY)") contractAddresses.KEYToken = address;
                        else if (name === "Subnet Registry") contractAddresses.SubnetRegistry = address;
                        else if (name === "Enhanced PoCW Verifier") contractAddresses.EnhancedPoCWVerifier = address;
                    }
                    updateContractABIs();
                    console.log("‚úÖ Updated contract addresses:", contractAddresses);
                }
            } catch (error) {
                console.log("‚ö†Ô∏è Using fallback addresses:", error.message);
            }
            updateContractABIs();
        }

        function waitForEthers() {
            if (typeof ethers !== 'undefined') {
                console.log("‚úÖ Ethers loaded");
                initializeApp();
            } else {
                console.log("‚è≥ Waiting for ethers...");
                setTimeout(waitForEthers, 100);
            }
        }
        
        async function initializeApp() {
            console.log("üöÄ Initializing app...");
            try {
                provider = new ethers.JsonRpcProvider("http://localhost:8545");
                console.log("‚úÖ Provider created");
                await loadContractAddresses();
                console.log("‚úÖ App initialized successfully");
            } catch (error) {
                console.error("‚ùå Init error:", error);
            }
        }

        async function checkNetwork() {
            try {
                console.log("üîç Checking network...");
                document.getElementById('network-status').innerHTML = `<div class="highlight">üîç Checking network...</div>`;
                
                const network = await provider.getNetwork();
                const blockNumber = await provider.getBlockNumber();
                const balance = await provider.getBalance("0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266");
                
                let networkName = network.name;
                if (network.chainId === 31337n || network.chainId === 1337n) {
                    networkName = "Anvil/Hardhat Local";
                }
                
                document.getElementById('network-status').innerHTML = `
                    <div class="success">‚úÖ Connected to ${networkName}</div>
                    <div><span class="highlight">Chain ID:</span> ${network.chainId}</div>
                    <div><span class="highlight">Latest Block:</span> ${blockNumber}</div>
                    <div><span class="highlight">Deployer Balance:</span> ${ethers.formatEther(balance)} ETH</div>
                    <div><span class="highlight">RPC URL:</span> http://localhost:8545</div>
                `;
            } catch (error) {
                console.error("‚ùå Network check failed:", error);
                document.getElementById('network-status').innerHTML = `
                    <div class="error">‚ùå Connection Failed: ${error.message}</div>
                    <div style="margin-top: 10px;">
                        <span class="highlight">Troubleshooting:</span><br>
                        ‚Ä¢ Make sure Anvil is running on http://localhost:8545<br>
                        ‚Ä¢ Check console for detailed error messages
                    </div>
                `;
            }
        }

        async function getLatestBlock() {
            try {
                const blockNumber = await provider.getBlockNumber();
                const block = await provider.getBlock(blockNumber);
                
                document.getElementById('network-status').innerHTML = `
                    <div class="success">üìÑ Latest Block Details</div>
                    <div><span class="highlight">Number:</span> ${block.number}</div>
                    <div><span class="highlight">Hash:</span> ${block.hash}</div>
                    <div><span class="highlight">Transactions:</span> ${block.transactions.length}</div>
                    <div><span class="highlight">Timestamp:</span> ${new Date(block.timestamp * 1000).toLocaleString()}</div>
                `;
            } catch (error) {
                document.getElementById('network-status').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function getBlock() {
            try {
                const blockNumberInput = document.getElementById('blockNumber').value.trim();
                const blockNumber = blockNumberInput ? parseInt(blockNumberInput) : await provider.getBlockNumber();
                
                document.getElementById('block-output').innerHTML = '<div class="highlight">üîç Loading block...</div>';
                
                const block = await provider.getBlock(blockNumber);
                if (!block) {
                    document.getElementById('block-output').innerHTML = '<div class="error">‚ùå Block not found</div>';
                    return;
                }
                
                const output = `
                    <div class="success">üìÑ Block ${block.number} Details</div>
                    <div><span class="highlight">Hash:</span> ${block.hash}</div>
                    <div><span class="highlight">Parent Hash:</span> ${block.parentHash}</div>
                    <div><span class="highlight">Timestamp:</span> ${new Date(block.timestamp * 1000).toLocaleString()}</div>
                    <div><span class="highlight">Gas Used:</span> ${block.gasUsed.toString()}</div>
                    <div><span class="highlight">Gas Limit:</span> ${block.gasLimit.toString()}</div>
                    <div><span class="highlight">Transactions:</span> ${block.transactions.length}</div>
                    ${block.transactions.length > 0 ? `<div><span class="highlight">Transaction Hashes:</span><br>${block.transactions.map(tx => `<span class="tx-hash">${tx}</span>`).join('<br>')}</div>` : ''}
                `;
                
                document.getElementById('block-output').innerHTML = output;
            } catch (error) {
                document.getElementById('block-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function getTransaction() {
            try {
                const txHash = document.getElementById('txHash').value.trim();
                if (!txHash) {
                    document.getElementById('tx-output').innerHTML = '<div class="error">‚ùå Please enter transaction hash</div>';
                    return;
                }
                
                document.getElementById('tx-output').innerHTML = '<div class="highlight">üîç Loading transaction...</div>';
                
                const tx = await provider.getTransaction(txHash);
                const receipt = await provider.getTransactionReceipt(txHash);
                
                if (!tx) {
                    document.getElementById('tx-output').innerHTML = '<div class="error">‚ùå Transaction not found</div>';
                    return;
                }
                
                const output = `
                    <div class="success">üìÑ Transaction Details</div>
                    <div><span class="highlight">Hash:</span> <span class="tx-hash">${tx.hash}</span></div>
                    <div><span class="highlight">From:</span> <span class="address">${tx.from}</span></div>
                    <div><span class="highlight">To:</span> <span class="address">${tx.to || 'Contract Creation'}</span></div>
                    <div><span class="highlight">Value:</span> ${ethers.formatEther(tx.value)} ETH</div>
                    <div><span class="highlight">Gas Price:</span> ${tx.gasPrice ? ethers.formatUnits(tx.gasPrice, "gwei") + " gwei" : 'N/A'}</div>
                    <div><span class="highlight">Gas Limit:</span> ${tx.gasLimit.toString()}</div>
                    <div><span class="highlight">Nonce:</span> ${tx.nonce}</div>
                    <div><span class="highlight">Block:</span> ${tx.blockNumber || 'Pending'}</div>
                    <div><span class="highlight">Status:</span> ${receipt ? (receipt.status === 1 ? '<span class="success">Success</span>' : '<span class="error">Failed</span>') : 'Pending'}</div>
                    ${receipt ? `<div><span class="highlight">Gas Used:</span> ${receipt.gasUsed.toString()}</div>` : ''}
                `;
                
                document.getElementById('tx-output').innerHTML = output;
            } catch (error) {
                document.getElementById('tx-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function getContractInfo() {
            try {
                const address = document.getElementById('contractSelect').value;
                
                document.getElementById('contract-output').innerHTML = '<div class="highlight">üîç Loading contract info...</div>';
                
                const code = await provider.getCode(address);
                const balance = await provider.getBalance(address);
                
                const output = `
                    <div class="success">üìÑ Contract: ${address}</div>
                    <div><span class="highlight">Address:</span> <span class="address">${address}</span></div>
                    <div><span class="highlight">Balance:</span> ${ethers.formatEther(balance)} ETH</div>
                    <div><span class="highlight">Is Contract:</span> ${code !== '0x' ? '<span class="success">Yes</span>' : '<span class="error">No</span>'}</div>
                `;
                
                document.getElementById('contract-output').innerHTML = output;
            } catch (error) {
                document.getElementById('contract-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function getAccountInfo() {
            try {
                const address = document.getElementById('accountAddress').value.trim();
                if (!address) {
                    document.getElementById('account-output').innerHTML = '<div class="error">‚ùå Please enter an address</div>';
                    return;
                }

                document.getElementById('account-output').innerHTML = '<div class="highlight">üîç Loading account...</div>';

                const ethBalance = await provider.getBalance(address);
                const transactionCount = await provider.getTransactionCount(address);
                const code = await provider.getCode(address);
                const isContract = code !== '0x';

                let output = `
                    <div class="success">üë§ Account: ${address}</div>
                    <div><span class="highlight">ETH Balance:</span> ${ethers.formatEther(ethBalance)} ETH</div>
                    <div><span class="highlight">Nonce:</span> ${transactionCount}</div>
                    <div><span class="highlight">Type:</span> ${isContract ? '<span class="highlight">Contract</span>' : 'EOA (Externally Owned Account)'}</div>
                `;

                // Known address roles
                const knownAddresses = {
                    "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266": "üîß Deployer", 
                    "0x70997970C51812dc3A010C7d01b50e0d17dc79C8": "‚úÖ Validator 1", 
                    "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC": "‚úÖ Validator 2",
                    "0x90F79bf6EB2c4f870365E785982E1f101E93b906": "‚úÖ Validator 3",
                    "0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65": "‚úÖ Validator 4",
                    "0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc": "‚õèÔ∏è Miner 1"
                };

                if (knownAddresses[address]) {
                    output += `<div style="margin-top: 10px;"><span class="highlight">Role:</span> ${knownAddresses[address]}</div>`;
                }

                // Try to get token balances
                try {
                    const hetuAddr = contractAddresses.HETUToken;
                    const hetuInterface = new ethers.Interface(contractABIs[hetuAddr]);
                    const hetuContract = new ethers.Contract(hetuAddr, hetuInterface, provider);
                    const hetuBalance = await hetuContract.balanceOf(address);
                    
                    const keyAddr = contractAddresses.KEYToken;
                    const keyInterface = new ethers.Interface(contractABIs[keyAddr]);
                    const keyContract = new ethers.Contract(keyAddr, keyInterface, provider);
                    const keyBalance = await keyContract.balanceOf(address);

                    output += `
                        <div style="margin-top: 15px;"><span class="highlight">Token Balances:</span></div>
                        <div style="margin-left: 20px;"><span class="highlight">HETU:</span> ${ethers.formatEther(hetuBalance)} HETU</div>
                        <div style="margin-left: 20px;"><span class="highlight">KEY:</span> ${ethers.formatEther(keyBalance)} KEY</div>
                    `;

                    // Get reputation scores from PoCW contract
                    try {
                        const pocwAddr = contractAddresses.EnhancedPoCWVerifier;
                        const pocwInterface = new ethers.Interface(contractABIs[pocwAddr]);
                        const pocwContract = new ethers.Contract(pocwAddr, pocwInterface, provider);
                        
                        let minerRep = 0, validatorRep = 0;
                        
                        try {
                            const result = await pocwContract.getReputationScores(address);
                            minerRep = result[0];
                            validatorRep = result[1];
                        } catch (repError) {
                            try {
                                minerRep = await pocwContract.calculateReputationScore(address);
                            } catch (e) { minerRep = 0; }
                            try {
                                validatorRep = await pocwContract.calculateValidatorReputationScore(address);
                            } catch (e) { validatorRep = 0; }
                        }
                        
                        if (Number(minerRep) > 0 && Number(validatorRep) > 0) {
                            output += `
                                <div style="margin-top: 15px;"><span class="highlight">Reputation Scores:</span></div>
                                <div style="margin-left: 20px;"><span class="highlight">Miner Reputation:</span> ${minerRep.toString()} points</div>
                                <div style="margin-left: 20px;"><span class="highlight">Validator Reputation:</span> ${validatorRep.toString()} points</div>
                            `;
                        } else if (Number(minerRep) > 0) {
                            output += `<div style="margin-top: 15px;"><span class="highlight">Miner Reputation:</span> ${minerRep.toString()} points</div>`;
                        } else if (Number(validatorRep) > 0) {
                            output += `<div style="margin-top: 15px;"><span class="highlight">Validator Reputation:</span> ${validatorRep.toString()} points</div>`;
                        }
                    } catch (repError) {
                        console.log("‚ö†Ô∏è Could not get reputation scores:", repError.message);
                    }
                } catch (tokenError) {
                    console.log("‚ö†Ô∏è Could not get token balances:", tokenError.message);
                }

                document.getElementById('account-output').innerHTML = output;
            } catch (error) {
                document.getElementById('account-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function getRecentTransactions() {
            try {
                document.getElementById('recent-tx-output').innerHTML = '<div class="highlight">üîç Loading transactions...</div>';
                
                const latestBlock = await provider.getBlockNumber();
                const transactions = [];
                
                for (let i = Math.max(0, latestBlock - 10); i <= latestBlock; i++) {
                    const block = await provider.getBlock(i);
                    if (block && block.transactions.length > 0) {
                        for (const txHash of block.transactions) {
                            const tx = await provider.getTransaction(txHash);
                            transactions.push({...tx, blockNumber: i});
                        }
                    }
                }
                
                const output = transactions.length > 0 ? `
                    <div class="success">üìÑ Recent Transactions (${transactions.length})</div>
                    ${transactions.slice(-10).reverse().map(tx => `
                        <div style="margin: 10px 0; padding: 10px; border: 1px solid #333; background: #111;">
                            <div><span class="highlight">Block ${tx.blockNumber}:</span> <span class="tx-hash">${tx.hash}</span></div>
                            <div><span class="highlight">From:</span> <span class="address">${tx.from}</span></div>
                            <div><span class="highlight">To:</span> <span class="address">${tx.to || 'Contract Creation'}</span></div>
                            <div><span class="highlight">Value:</span> ${ethers.formatEther(tx.value)} ETH</div>
                        </div>
                    `).join('')}
                ` : '<div class="error">No recent transactions found</div>';
                
                document.getElementById('recent-tx-output').innerHTML = output;
            } catch (error) {
                document.getElementById('recent-tx-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        async function decodeTransaction() {
            try {
                const txHash = document.getElementById('decodeTxHash').value.trim();
                if (!txHash) {
                    document.getElementById('decode-output').innerHTML = '<div class="error">‚ùå Please enter transaction hash</div>';
                    return;
                }
                
                console.log("üîç Decoding transaction:", txHash);
                document.getElementById('decode-output').innerHTML = '<div class="highlight">üîç Loading transaction...</div>';
                
                const tx = await provider.getTransaction(txHash);
                const receipt = await provider.getTransactionReceipt(txHash);
                
                if (!tx) {
                    document.getElementById('decode-output').innerHTML = '<div class="error">‚ùå Transaction not found</div>';
                    return;
                }
                
                let output = `
                    <div class="success">üîç Transaction Decoder</div>
                    <div><span class="highlight">Hash:</span> <span class="tx-hash">${tx.hash}</span></div>
                    <div><span class="highlight">To Contract:</span> <span class="address">${tx.to}</span></div>
                    <div><span class="highlight">Status:</span> ${receipt.status === 1 ? '<span class="success">Success</span>' : '<span class="error">Failed</span>'}</div>
                `;

                // Decode function call if we have the ABI
                console.log("üîç Transaction decoding debug:");
                console.log("  - tx.data:", tx.data);
                console.log("  - tx.to:", tx.to);
                console.log("  - Has tx.data:", !!(tx.data && tx.data !== '0x'));
                console.log("  - Has ABI for contract:", !!contractABIs[tx.to]);
                console.log("  - Available contractABIs keys:", Object.keys(contractABIs));
                
                if (tx.data && tx.data !== '0x') {
                    const functionSelector = tx.data.slice(0, 10);
                    console.log("  - Function selector:", functionSelector);
                    
                    if (contractABIs[tx.to]) {
                        console.log("  - ABI for contract:", contractABIs[tx.to]);
                        
                        try {
                            const contractInterface = new ethers.Interface(contractABIs[tx.to]);
                            console.log("  - Contract interface created successfully");
                            const decoded = contractInterface.parseTransaction({ data: tx.data, value: tx.value });
                            console.log("  - Transaction decoded successfully:", decoded);
                        
                            output += `
                                <div style="margin-top: 15px;"><span class="highlight">Function Call:</span></div>
                                <div style="margin-left: 20px;"><span class="highlight">Function:</span> ${decoded.name}</div>
                            `;
                        
                            if (decoded.args && decoded.args.length > 0) {
                                output += `<div style="margin-left: 20px;"><span class="highlight">Parameters:</span></div>`;
                                decoded.args.forEach((arg, idx) => {
                                    const param = decoded.fragment.inputs[idx];
                                    let value = arg.toString();
                                    
                                    // Format specific types
                                    if (param.type === 'uint256' && value.length > 10) {
                                        value = `${ethers.formatEther(arg)} (${value} wei)`;
                                    } else if (param.type === 'bytes32') {
                                        value = `${arg} (32-byte hash)`;
                                    } else if (param.type === 'bytes' && value.startsWith('0x')) {
                                        try {
                                            const decoded_bytes = ethers.toUtf8String(arg);
                                            if (decoded_bytes.includes('{') && decoded_bytes.includes('}')) {
                                                try {
                                                    const jsonData = JSON.parse(decoded_bytes);
                                                    value = `<div style="background: #0a0a0a; padding: 10px; margin: 5px 0; border: 1px solid #333;">
                                                        <div style="color: #ffff00;">üìä VLC Graph Data:</div>
                                                        <pre style="color: #00ff00; font-size: 11px; margin: 5px 0; white-space: pre-wrap;">${JSON.stringify(jsonData, null, 2)}</pre>
                                                    </div>`;
                                                } catch (jsonError) {
                                                    value = `Text data: "${decoded_bytes}"`;
                                                }
                                            } else {
                                                value = `Text: "${decoded_bytes.replace(/\0/g, '')}"`;
                                            }
                                        } catch (e) {
                                            value = `Binary data (${(value.length - 2) / 2} bytes): ${value.substring(0, 50)}${value.length > 50 ? '...' : ''}`;
                                        }
                                    } else if (param.type.includes('address')) {
                                        if (Array.isArray(arg)) {
                                            value = arg.map(addr => `<span class="address">${addr}</span>`).join(', ');
                                        } else {
                                            value = `<span class="address">${arg}</span>`;
                                        }
                                    } else if (param.type === 'string') {
                                        value = `"${arg}"`;
                                    } else if (param.type.includes('[]')) {
                                        if (Array.isArray(arg)) {
                                            value = `[${arg.join(', ')}] (${arg.length} items)`;
                                        } else {
                                            value = arg.toString();
                                        }
                                    } else if (param.type === 'bool') {
                                        value = arg ? '‚úÖ true' : '‚ùå false';
                                    }
                                    
                                    output += `<div style="margin-left: 40px;">${param.name} (${param.type}): ${value}</div>`;
                                });
                            }
                        } catch (e) {
                            console.log("‚ùå Failed to decode transaction:", e);
                            console.log("  - Error message:", e.message);
                            output += `<div style="margin-top: 10px;"><span class="error">Could not decode function call: ${e.message}</span></div>`;
                            output += `<div style="margin-top: 10px;"><span class="highlight">Raw Data:</span> ${tx.data}</div>`;
                        }
                    } else {
                        console.log("‚ö†Ô∏è Cannot decode transaction:");
                        if (!tx.data || tx.data === '0x') {
                            console.log("  - No transaction data");
                        } else if (!contractABIs[tx.to]) {
                            console.log("  - No ABI available for contract:", tx.to);
                        }
                    }
                    
                    if (tx.data && tx.data !== '0x') {
                        output += `<div style="margin-top: 10px;"><span class="highlight">Raw Input Data:</span><br><div style="word-break: break-all; font-size: 10px; background: #0a0a0a; padding: 10px;">${tx.data}</div></div>`;
                    }
                }

                // Decode events
                if (receipt.logs && receipt.logs.length > 0) {
                    output += `<div style="margin-top: 15px;"><span class="highlight">Events Emitted (${receipt.logs.length}):</span></div>`;
                    
                    receipt.logs.forEach((log, idx) => {
                        if (contractABIs[log.address]) {
                            try {
                                const contractInterface = new ethers.Interface(contractABIs[log.address]);
                                const parsedLog = contractInterface.parseLog(log);
                                
                                output += `
                                    <div style="margin-left: 20px; border-left: 2px solid #333; padding-left: 10px; margin: 5px 0;">
                                        <div><span class="highlight">Event:</span> ${parsedLog.name}</div>
                                        <div><span class="highlight">Contract:</span> <span class="address">${log.address}</span></div>
                                `;
                                
                                if (parsedLog.args && parsedLog.args.length > 0) {
                                    parsedLog.args.forEach((arg, argIdx) => {
                                        const input = parsedLog.fragment.inputs[argIdx];
                                        let value = arg.toString();
                                        
                                        if (input.type === 'uint256' && value.length > 10) {
                                            value = `${ethers.formatEther(arg)} tokens`;
                                        } else if (input.type.includes('address')) {
                                            value = `<span class="address">${arg}</span>`;
                                        }
                                        
                                        output += `<div style="margin-left: 20px;">${input.name}: ${value}</div>`;
                                    });
                                }
                                output += `</div>`;
                            } catch (e) {
                                output += `
                                    <div style="margin-left: 20px; border-left: 2px solid #333; padding-left: 10px; margin: 5px 0;">
                                        <div>Event ${idx}: <span class="address">${log.address}</span></div>
                                        <div>Topics: ${log.topics.length}</div>
                                    </div>
                                `;
                            }
                        } else {
                            output += `
                                <div style="margin-left: 20px; border-left: 2px solid #333; padding-left: 10px; margin: 5px 0;">
                                    <div>Event ${idx}: <span class="address">${log.address}</span></div>
                                    <div>Topics: ${log.topics.length}</div>
                                </div>
                            `;
                        }
                    });
                }

                document.getElementById('decode-output').innerHTML = output;
            } catch (error) {
                console.error("‚ùå Decode error:", error);
                document.getElementById('decode-output').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        // Start waiting for ethers
        waitForEthers();
    </script>
</body>
</html>